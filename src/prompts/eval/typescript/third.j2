Implement functional Result<T, E> and Option<T> types with chainable methods.
API:

typescript
const result = Result.ok(42)
  .map(x => x * 2)
  .andThen(x => x > 50 ? Result.ok(x) : Result.err("too small"));

if (result.isOk()) {
  console.log(result.value); // type narrowed to number
}
Requirements:

Result<T, E> with .ok(), .err(), .map(), .mapErr(), .andThen(), .unwrap().

Option<T> with .some(), .none(), .map(), .filter(), .unwrap().

Type guards: .isOk(), .isErr(), .isSome(), .isNone() narrow types.

No runtime classes, use discriminated unions ({ kind: 'ok', value: T }).
Tests:

Chaining transformations.

Error propagation with .andThen().

Type narrowing in conditionals.