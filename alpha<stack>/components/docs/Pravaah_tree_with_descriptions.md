# File System Tree for Pravaah

## Structure with Descriptions

Pravaah
  - **{project-root}/**
    - *Description: This is the root directory for the "Pravaah" project, a full-stack application. It organizes the entire codebase into distinct, high-level components including the backend, a high-performance Rust core, the frontend, infrastructure definitions, CI/CD pipelines, and project-wide documentation.*
  - **.github/**
    - **workflows/**
      - **ci.yml**
        - *Description: This YAML file defines the Continuous Integration (CI) pipeline using GitHub Actions. It automates the process of running linters, tests, and builds for the frontend, backend, and Rust core components whenever code is pushed or a pull request is created.*
      - **cd.yml**
        - *Description: This GitHub Actions workflow file defines the Continuous Deployment (CD) pipeline for the project. It automates the process of building and pushing the frontend and backend Docker images to a container registry and then deploying the new versions to a Kubernetes environment.*
  - **backend/**
    - **gati/**
      - **__init__.py**
        - *Description: This file marks the `gati` directory as a Python package, allowing its submodules (like `api`, `core`, and `db`) to be imported by other parts of the backend application. It can be empty or contain package-level initialization code.*
      - **api/**
        - **__init__.py**
          - *Description: This `__init__.py` file marks the `api` directory as a Python package, enabling its modules and sub-packages (like the versioned API router in `v1`) to be imported elsewhere. It may also be used to aggregate routers from different versions into a single master API router for the FastAPI application.*
        - **v1/**
          - **__init__.py**
            - *Description: This `__init__.py` file marks the `v1` directory as a Python package, allowing its contents to be imported. It often serves to aggregate the various API routers from the `endpoints` sub-directory into a single, versioned router that can be included in the main FastAPI application.*
          - **endpoints/**
            - **__init__.py**
              - *Description: This `__init__.py` file marks the `endpoints` directory as a Python package. Its presence allows the FastAPI application to import the various API router modules (like `auth.py`, `jobs.py`) contained within this directory.*
            - **auth.py**
              - *Description: This file defines the FastAPI API endpoints for user authentication and authorization. It contains the public-facing routes for handling user login, validating credentials, and issuing access tokens for clients to use in subsequent requests.*
            - **jobs.py**
              - *Description: This file defines the FastAPI API endpoints for managing background jobs. It is responsible for handling HTTP requests to create, retrieve status, list, and manage asynchronous tasks within the application.*
            - **users.py**
              - *Description: This file defines the REST API endpoints for user management within the `gati` backend service. It contains the request handlers for operations like creating new users, retrieving user details, updating user information, and deleting user accounts.*
          - **schemas.py**
            - *Description: This file contains Pydantic schemas that define the data structures for the v1 API's request bodies and response models. It is responsible for data validation, serialization, and ensuring a consistent data contract between the frontend and backend.*
      - **auth/**
        - **__init__.py**
          - *Description: This `__init__.py` file designates the `auth` directory as a Python package, allowing its modules (`jwt.py`, `security.py`) to be imported throughout the application. It may also define a simplified public API for the package by exposing key functions and classes from its submodules.*
        - **jwt.py**
          - *Description: This file is responsible for handling JSON Web Token (JWT) operations. It contains the logic to create (encode) new access tokens for authenticated users and to decode and validate incoming tokens to verify user identity for protected API endpoints.*
        - **security.py**
          - *Description: This file defines the FastAPI security dependencies and schemes used to protect API endpoints. It likely contains the `OAuth2PasswordBearer` setup and the dependency function that endpoints use to require a valid token, verify it, and retrieve the current authenticated user.*
      - **core/**
        - **__init__.py**
          - *Description: This file marks the `core` directory as a Python package, enabling other parts of the backend application to import its modules, such as configuration settings and application lifecycle events.*
        - **config.py**
          - *Description: This file centralizes the backend application's configuration by defining and managing settings loaded from environment variables. It provides a single source for parameters such as database credentials, secret keys, and external service URLs used throughout the application.*
        - **lifespan.py**
          - *Description: This file manages the FastAPI application's lifecycle events. It contains the logic for startup and shutdown procedures, such as initializing database connection pools or message queues when the application starts, and gracefully closing them when it stops.*
      - **db/**
        - **__init__.py**
          - *Description: This `__init__.py` file designates the `db` directory as a Python package, allowing other parts of the application to import its database-related modules, such as `models`, `crud`, and `session`. It may also be used to control the package's namespace and expose key database components for easier access.*
        - **crud.py**
          - *Description: This file contains the data access logic, implementing the Create, Read, Update, and Delete (CRUD) operations for the application's database models. It acts as an abstraction layer, providing reusable functions that the API endpoints call to interact with the database, separating business logic from data persistence details.*
        - **models.py**
          - *Description: This file defines the database schema using Python classes, which map to tables in the database via an Object-Relational Mapper (ORM) like SQLModel or SQLAlchemy. Each class within `models.py` represents a database table, and its attributes correspond to the table's columns.*
        - **session.py**
          - *Description: This file is responsible for initializing the application's database connection and managing database sessions. It typically creates the SQLAlchemy/SQLModel engine and a session factory, and provides a dependency function for FastAPI to inject a database session into API endpoints for each request.*
      - **integrations/**
        - **__init__.py**
          - *Description: This `__init__.py` file designates the `integrations` directory as a Python package, making its modules, which contain logic for connecting to external services (like S3), importable throughout the application.*
        - **s3.py**
          - *Description: This file defines a client or helper functions for interacting with an S3-compatible object storage service. It encapsulates the logic for operations like uploading, downloading, and managing files, providing a standardized interface for other parts of the backend application.*
      - **tasks/**
        - **__init__.py**
          - *Description: This `__init__.py` file marks the `tasks` directory as a Python package, allowing its modules containing background job definitions (e.g., Celery tasks) to be imported. It might also be used to initialize the Celery app or expose specific tasks at the package level for easier discovery.*
        - **filesystem_ops.py**
          - *Description: This file defines asynchronous background tasks, likely using Celery, for performing I/O-intensive filesystem operations. It contains the logic for jobs like scanning directories, moving files, or analyzing file metadata, which are executed by a separate worker process to avoid blocking the main API.*
        - **task_utils.py**
          - *Description: This file provides reusable helper functions specifically for the Celery background tasks defined in this directory. It likely contains common logic, such as updating job statuses in the database, logging progress, or handling errors, which is shared across multiple tasks.*
      - **utils/**
        - **__init__.py**
          - *Description: This `__init__.py` file designates the `utils` directory as a Python package, allowing its modules (like `logging.py`) to be imported elsewhere in the application. It may also be used to expose specific utility functions at the package level for more convenient access.*
        - **logging.py**
          - *Description: This file, `gati/utils/logging.py`, should contain the centralized configuration for the application's logging. It is responsible for setting up log formats, levels, and handlers (e.g., console, file) to ensure consistent logging across the entire backend, including the FastAPI application and Celery workers.*
      - **main.py**
        - *Description: This file, `main.py`, is the primary entry point for the Gati FastAPI web application. It instantiates the FastAPI application, mounts the API routers from the `api/` directory, and configures application-level settings like middleware and lifespan events.*
      - **worker.py**
        - *Description: This file serves as the entrypoint for launching the Celery background worker processes. It is responsible for creating and configuring the Celery application instance, which discovers and executes asynchronous tasks defined in the `gati/tasks/` directory.*
    - **tests/**
      - **__init__.py**
        - *Description: This file marks the `tests` directory and its subdirectories as a Python package, allowing the test runner (like pytest) to discover and import the test modules contained within it. It is essential for structuring the test suite and is often left empty.*
      - **conftest.py**
        - *Description: This is a special `pytest` configuration file that defines shared test fixtures, hooks, and plugins for the backend test suite. It centralizes setup and teardown logic, such as initializing a test database or creating an API test client, making these resources available to all tests within the `tests` directory.*
      - **integration/**
        - **__init__.py**
          - *Description: This file marks the `tests/integration` directory as a Python package, allowing test discovery tools like `pytest` to find and execute the integration tests within it. It is often empty, as its presence is what enables the test runner to import modules from this directory.*
        - **test_api_jobs.py**
          - *Description: This file contains integration tests for the job management API endpoints (defined in `backend/gati/api/v1/endpoints/jobs.py`). It simulates real HTTP requests to create, retrieve, and manage jobs, verifying that the API layer, database interactions, and business logic integrate and function correctly.*
      - **unit/**
        - **__init__.py**
          - *Description: This file marks the `unit` directory as a Python package, enabling the test runner (e.g., pytest) to discover and import the unit tests contained within this folder. It is often intentionally left empty.*
        - **test_auth.py**
          - *Description: This file contains unit tests for the backend's authentication and authorization modules. It is responsible for verifying the correctness of individual functions, such as JWT creation/decoding and password verification, in isolation from the database or API endpoints.*
    - **.env.example**
      - *Description: This file serves as a template listing all the required environment variables for the backend application. Developers should copy it to a `.env` file and populate it with their specific local configuration values, such as database credentials and secret keys, to run the project.*
    - **poetry.lock**
      - *Description: This auto-generated file locks the exact versions of all Python packages and their sub-dependencies for the backend application, as defined in `pyproject.toml`. Its purpose is to ensure consistent, reproducible builds and environments for development, testing, and production.*
    - **pyproject.toml**
      - *Description: This file is the project definition file for the Python backend, managed using the Poetry dependency manager. It declares project metadata, specifies application and development dependencies (e.g., FastAPI, pytest), and configures development tools like linters and formatters.*
  - **core/**
    - **src/**
      - **__init__.py**
        - *Description: This `__init__.py` file marks the `src` directory as a Python package, which is a requirement for PyO3 to allow the compiled Rust core engine to be correctly imported and used by the Python backend.*
      - **error.rs**
        - *Description: This file defines the custom error types for the Rust `core` library. It consolidates all potential failures, such as I/O or data processing errors, into a unified type for robust, idiomatic error handling within the Rust codebase and for exposing exceptions to the Python layer.*
      - **filesystem/**
        - **mod.rs**
          - *Description: This file, `mod.rs`, serves as the Rust module declaration for the `filesystem` directory. It is responsible for defining the module's public API by declaring its sub-modules (like `scanner.rs`) and re-exporting their relevant components for use by the rest of the `core` crate.*
        - **scanner.rs**
          - *Description: This Rust source file implements high-performance logic for recursively scanning directories. It is responsible for efficiently traversing the filesystem to discover files and gather their metadata, a core function likely exposed to the Python backend for performance-critical operations.*
      - **lib.rs**
        - *Description: `lib.rs` is the main entry point for the Rust library (`pravaah_core`). It defines the crate's public API and uses the PyO3 framework to expose high-performance Rust functions and types as a callable Python module for the backend.*
      - **processing/**
        - **mod.rs**
          - *Description: This file, `mod.rs`, is the Rust module declaration for the `processing` directory. It defines the module's public interface and exposes its submodules, such as `parallel.rs`, to the rest of the high-performance Rust `core` crate.*
        - **parallel.rs**
          - *Description: This Rust source file implements high-performance, parallel data processing logic for the core engine. It likely uses libraries like Rayon to distribute computationally intensive tasks, such as filtering or transforming large datasets of file metadata, across multiple CPU cores for maximum speed.*
      - **types/**
        - **mod.rs**
          - *Description: This file, `mod.rs`, serves as the module declaration for the `types` directory within the Rust `core` crate. Its purpose is to define the public API of the `types` module by exporting the data structures (like structs and enums) defined in other files within this directory, such as `file_meta.rs`.*
        - **file_meta.rs**
          - *Description: This Rust source file defines the core data structures, likely `structs`, used to represent file metadata. It encapsulates properties like file path, size, and modification times, serving as the primary data model for the file scanning and processing operations within the high-performance Rust engine.*
    - **tests/**
      - **scanner_tests.rs**
        - *Description: This file contains Rust integration tests for the high-performance directory traversal and file metadata collection logic defined in `core/src/filesystem/scanner.rs`. It ensures the scanner behaves correctly by creating temporary file/directory structures and asserting the scan results are accurate.*
    - **benches/**
      - **scan_benchmark.rs**
        - *Description: This Rust file contains performance benchmarks for the filesystem scanning functionality of the `core` library. It is designed to measure the speed and efficiency of the directory traversal logic using Rust's `cargo bench` command.*
    - **Cargo.toml**
      - *Description: This is the manifest file for the `core` Rust project, managed by Rust's build system, Cargo. It defines the crate's metadata, its dependencies (like `pyo3` for Python bindings and `rayon` for parallelism), and the necessary build configuration to compile it into a library that can be used by the Python backend.*
  - **docs/**
    - **api/**
      - *Description: This directory is designated for API documentation, such as OpenAPI or Swagger specifications. It provides a detailed, machine-readable reference for the backend's endpoints, defining their structure, request/response formats, and authentication requirements.*
    - **architecture.md**
      - *Description: This Markdown file serves as the primary documentation for the project's high-level system architecture. It is expected to contain diagrams, design principles, and explanations of how major components like the frontend, backend, and core processing engine interact with each other.*
    - **user_guide.md**
      - *Description: This Markdown file contains the user guide, providing end-users with comprehensive instructions, tutorials, and feature explanations on how to use the Pravaah application. It serves as the primary "how-to" manual for operating the software from a user's perspective.*
  - **frontend/**
    - **public/**
      - **favicon.ico**
        - *Description: This file is the website's "favicon," a small icon that web browsers display in the address bar, browser tabs, and bookmark lists. Its placement in the `public` directory ensures it is served as a static asset to provide a visual brand identity for the application.*
      - **logo.svg**
        - *Description: This file is the main logo for the Pravaah web application, stored as a Scalable Vector Graphic (SVG). Located in the `frontend/public` directory, it is served directly as a static asset for branding purposes across the user interface.*
    - **src/**
      - **app/**
        - **api/**
          - *Description: This directory contains server-side API Route Handlers for the Next.js application, following the App Router convention. It allows the frontend to have its own backend endpoints, which can be used to securely communicate with the main Python backend, manage sessions, or handle other server-only logic.*
        - **dashboard/**
          - **layout.tsx**
            - *Description: This file defines the shared UI layout for all pages within the `/dashboard` section of the Next.js application. It typically includes persistent components like a navigation bar, sidebar, or header that wrap the content of individual dashboard pages.*
          - **page.tsx**
            - *Description: Based on its location and name, `page.tsx` is the primary React component that defines the user interface for the `/dashboard` route. This file is the main view users see after logging in, responsible for displaying key application data, controls, and status information, such as managing and monitoring data processing jobs.*
        - **login/**
          - **page.tsx**
            - *Description: This file defines the React component that renders the user interface for the `/login` route. It contains the login form, handles user input, and manages the logic for authenticating users against the backend API.*
        - **globals.css**
          - *Description: This file defines the global CSS styles for the entire Next.js frontend application. It typically contains CSS resets, base styles for HTML elements, and the necessary `@tailwind` directives to inject Tailwind CSS's foundational styles across all pages and components.*
        - **layout.tsx**
          - *Description: This file is the root layout for the Next.js application, defining the main HTML structure (like `<html>` and `<body>` tags) and shared UI components that wrap every page. It is responsible for applying global styles, fonts, and providing a consistent shell for the entire user interface.*
        - **page.tsx**
          - *Description: This file defines the main landing page or home page for the Next.js application, rendering the UI for the root URL (`/`). It is the primary entry point for users visiting the site and may redirect to the login page or dashboard based on authentication status.*
      - **components/**
        - **jobs/**
          - **JobProgressBar.tsx**
            - *Description: This file defines a reusable React component, `JobProgressBar.tsx`, responsible for visually displaying the progress of a background job. It likely receives the job's status and completion percentage as props to render a dynamic progress bar for the user interface.*
        - **layout/**
          - **Navbar.tsx**
            - *Description: This file defines the main navigation bar React component for the application's user interface. It is a reusable layout element responsible for displaying the application logo, navigation links, and user-related controls like login or logout buttons.*
        - **ui/**
          - **Button.tsx**
            - *Description: This file defines a reusable, general-purpose UI button component for the frontend application. It is used to ensure a consistent look and feel for all buttons across the user interface and likely accepts props to control its appearance (e.g., variant, size) and behavior.*
      - **hooks/**
        - **useAuth.ts**
          - *Description: This file defines the `useAuth` custom React hook, which encapsulates authentication logic for the frontend application. It provides React components with a simple interface to access the current user's authentication status, user data, and functions like login and logout.*
      - **lib/**
        - **api.ts**
          - *Description: This file defines the frontend's type-safe API client for communicating with the FastAPI backend. It centralizes all HTTP request logic, providing functions for specific endpoints and managing details like authentication headers and base URLs.*
        - **auth.ts**
          - *Description: This file contains client-side authentication logic and helper functions for the frontend application. It is responsible for managing user sessions, handling authentication tokens (e.g., JWTs), and providing utilities for login, logout, and checking the current user's authentication status.*
      - **types/**
        - **index.ts**
          - *Description: This file serves as the central module for all shared TypeScript type definitions used in the frontend application. It likely exports interfaces, types, and enums for data structures such as API responses, component props, and application state, providing a single, convenient import point for the rest of the codebase.*
    - **tests/**
      - **e2e/**
        - **auth.spec.ts**
          - *Description: This file contains end-to-end (E2E) tests for the user authentication flow of the frontend application. It simulates real user interactions, such as logging in with valid/invalid credentials and logging out, to verify that the entire authentication system works correctly from the user's perspective in a browser environment.*
      - **component/**
        - **Button.test.tsx**
          - *Description: This file contains component tests for the reusable `Button` UI component (`src/components/ui/Button.tsx`). It uses a testing framework like Jest or Vitest to verify that the button renders correctly, handles user interactions such as clicks, and properly reflects different states and props (e.g., disabled, variant styles).*
    - **.env.local.example**
      - *Description: This file is a template that lists the environment variables required for running the frontend application in a local development environment. Developers should copy this file to `.env.local` and fill in the specific values, such as the backend API endpoint URL, for their local setup.*
    - **next.config.mjs**
      - *Description: This file is the main configuration file for the Next.js frontend application. It allows developers to customize the framework's default behavior, such as setting up redirects, managing environment variables, and configuring the build process.*
    - **package.json**
      - *Description: This file is the standard Node.js project manifest for the frontend application. It defines project metadata, lists dependencies (e.g., React, Next.js, Tailwind CSS), and contains `scripts` for tasks like running the development server, building for production, and executing tests.*
    - **postcss.config.js**
      - *Description: This file configures PostCSS, a tool used to transform CSS with JavaScript plugins. Its primary role in this Next.js project is to define the plugins, such as Tailwind CSS and Autoprefixer, that process the project's stylesheets during the build process.*
    - **tailwind.config.ts**
      - *Description: This TypeScript file configures the Tailwind CSS framework for the Next.js frontend. It is used to define the project's design system, including custom themes (colors, fonts, spacing), plugins, and specifying which source files to scan for utility classes.*
    - **tsconfig.json**
      - *Description: This file is the TypeScript compiler configuration for the Next.js frontend application. It defines the rules and settings for transpiling TypeScript code (`.ts`, `.tsx`) into JavaScript, enabling features like static type-checking, module resolution, and path aliases.*
  - **infra/**
    - **kubernetes/**
      - **base/**
        - **api-deployment.yaml**
          - *Description: This file is a Kubernetes `Deployment` manifest that defines how to run the backend API service on a Kubernetes cluster. As a Kustomize `base` configuration, it contains the common, environment-agnostic specifications for the API pods, including the container image, replica count, and resource requirements.*
        - **configmap.yaml**
          - *Description: This file defines a base Kubernetes `ConfigMap` resource using Kustomize. It stores non-sensitive, environment-agnostic configuration data as key-value pairs, which are consumed by the various application pods (backend API, workers, frontend) at runtime.*
        - **frontend-deployment.yaml**
          - *Description: This YAML file is a baseline Kubernetes `Deployment` manifest for the project's frontend application. It defines the desired state for the frontend service, including the container image to use, the number of replicas, and how to perform updates, which serves as a common template for all deployment environments.*
        - **kustomization.yaml**
          - *Description: This is the primary Kustomize configuration file for the `base` layer. It defines the common, environment-agnostic Kubernetes resources for the application by referencing all other manifest files (like `api-deployment.yaml`, `service.yaml`) within this directory.*
        - **service.yaml**
          - *Description: This file is a Kubernetes manifest that defines a base `Service` resource. Its purpose is to create a stable network endpoint, such as an internal IP address or DNS name, for accessing the application's pods (like the backend API or frontend) within the Kubernetes cluster.*
        - **worker-deployment.yaml**
          - *Description: This file is a base Kubernetes `Deployment` manifest for the application's background worker processes (e.g., Celery). It defines the core, environment-agnostic configuration for deploying and managing the worker pods that execute asynchronous tasks within the cluster.*
      - **overlays/**
        - **production/**
          - **kustomization.yaml**
            - *Description: This Kustomize configuration file defines the production environment's specific settings for the Kubernetes deployment. It references the common manifests from the `base` directory and applies production-specific patches and overrides, such as scaling configurations or image tags.*
          - **scaling-patch.yaml**
            - *Description: This Kustomize patch file defines production-specific scaling configurations, such as replica counts and resource requests/limits, for the Kubernetes deployments. It overrides the base configurations to ensure the application is provisioned with appropriate resources to handle production-level traffic.*
        - **staging/**
          - **kustomization.yaml**
            - *Description: This Kustomize configuration file orchestrates the Kubernetes deployment for the **staging** environment. It references the common manifests in the `base` directory and applies staging-specific patches, such as `config-patch.yaml`, to customize the application's configuration for pre-production testing.*
          - **config-patch.yaml**
            - *Description: This file is a Kustomize patch that defines environment-specific configuration values for the staging deployment. It overrides or extends the base `ConfigMap` to provide settings, such as API endpoints or log levels, tailored specifically for the staging environment.*
  - **.dockerignore**
    - *Description: The `.dockerignore` file lists patterns for files and directories that should be excluded from the Docker build context when creating container images. This prevents unnecessary or sensitive files like Git history, local dependencies, and test artifacts from being copied into the image, resulting in smaller, faster, and more secure builds for both the backend and frontend services.*
  - **.gitignore**
    - *Description: This file specifies intentionally untracked files and directories for the Git version control system. Its purpose is to prevent build artifacts, local configuration files, dependency folders, and other generated files from being committed to the repository.*
  - **docker-compose.yml**
    - *Description: This file defines and configures the multi-container application for local development using Docker Compose. It orchestrates the building and running of all necessary services, such as the backend API, frontend, database, and message broker, to create a consistent development environment.*
  - **Dockerfile.backend**
    - *Description: This file is a Docker build script used to create a container image for the Python backend application. It defines the environment, dependencies (from `pyproject.toml`), and runtime commands needed to run both the FastAPI web server and the Celery background workers.*
  - **Dockerfile.frontend**
    - *Description: This `Dockerfile` contains the instructions to build a production-ready, containerized Docker image for the Next.js frontend application. It defines a multi-stage build process to create a lightweight and optimized image for deployment.*
  - **LICENSE**
    - *Description: This file contains the legal license for the software, defining the terms under which others may use, modify, and distribute the project's code. It is a crucial legal document that specifies the permissions and restrictions for anyone interacting with the project.*
  - **Makefile**
    - *Description: The `Makefile` is a build automation script that defines a set of convenient command-line shortcuts for common development tasks. It orchestrates commands across the project's various components, such as building services, running tests, linting code, and managing the local development environment.*
  - **README.md**
    - *Description: The `README.md` file serves as the project's main documentation, providing a high-level overview of the "Pravaah" application, its purpose, and key features. It contains essential instructions for developers on how to set up, configure, and run the project locally.*
