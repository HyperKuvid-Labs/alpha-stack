# File System Tree for Pravaah

## Structure with Descriptions

Pravaah
  - **{project-root}/**
    - *Description: This is the root directory of the `Pravaah` project, structured as a monorepo that contains all source code, configuration, and documentation. It organizes the entire application into distinct, high-level components like `frontend`, `backend`, `rust_engine`, and `infrastructure`.*
  - **.env.example**
    - *Description: This file is a template listing all the environment variables required for local development. Developers should copy it to a `.env` file and populate it with their specific configuration values and secrets to run the project.*
  - **.github/**
    - **workflows/**
      - **ci.yml**
        - *Description: This file is a GitHub Actions workflow that defines the Continuous Integration (CI) pipeline. It automatically runs quality checks like linting, tests, and build validations for all project components (backend, frontend, Rust engine) on events such as pull requests.*
      - **cd.yml**
        - *Description: This YAML file defines the GitHub Actions workflow for Continuous Deployment (CD). It automates the process of building, packaging, and deploying the application to staging and production environments, typically triggered after code is merged into the main branch or a new tag is created.*
  - **.gitignore**
    - *Description: The `.gitignore` file specifies files and directories that Git should ignore, preventing them from being tracked in version control. It's used to exclude local configurations, dependencies, build artifacts, and other generated files from the repository.*
  - **README.md**
    - *Description: **README.md**: This file serves as the main entry point for understanding the project. It typically contains a high-level overview of the Pravaah application, its purpose, and essential instructions for setup, installation, and basic usage.*
  - **backend/**
    - **pyproject.toml**
      - *Description: This file defines the backend Python project's metadata, dependencies, and development tool configurations. It is used by package managers like Poetry or PDM to install dependencies, run scripts, and build the project.*
    - **src/**
      - **karyaksham_api/**
        - **__init__.py**
          - *Description: This file marks the `karyaksham_api` directory as a Python package, making its modules and sub-packages (like `api`, `core`, `crud`, and `db`) importable by other parts of the application. It can also contain package-level initialization code or expose key objects from its submodules.*
        - **api/**
          - **__init__.py**
            - *Description: This `__init__.py` file marks the `api` directory as a Python package, allowing its contents, such as different API versions (`v1`), to be imported. It serves as the entry point for the API module structure within the `karyaksham_api` application.*
          - **v1/**
            - **__init__.py**
              - *Description: This file marks the `v1` directory as a Python package, allowing its contents—such as the main v1 API router and specific endpoint modules—to be imported and used by the main FastAPI application. It is essential for organizing the API endpoints under the `/api/v1` namespace.*
            - **api.py**
              - *Description: This file acts as the central router for the `v1` API. It aggregates all the individual endpoint routers (e.g., for users, jobs, auth) from the `endpoints` subdirectory into a single `APIRouter`, which is then included in the main FastAPI application.*
            - **endpoints/**
              - **__init__.py**
                - *Description: This `__init__.py` file marks the `endpoints` directory as a Python package. This allows the FastAPI application to discover and import the individual API endpoint router modules (like `auth.py`, `jobs.py`, etc.) contained within this directory.*
              - **auth.py**
                - *Description: This file defines the API endpoints for user authentication, such as login and registration. It handles incoming HTTP requests for user sign-up and sign-in, validates credentials, and returns access tokens upon success.*
              - **jobs.py**
                - *Description: This file defines the FastAPI API endpoints for managing processing jobs. It contains the HTTP route handlers for creating, retrieving, listing, and updating job resources, acting as the web layer for all job-related operations.*
              - **users.py**
                - *Description: This file defines the FastAPI API endpoints for managing user resources. It contains the routes for performing CRUD (Create, Read, Update, Delete) operations, such as retrieving a list of users, fetching a specific user's details, and updating user information.*
        - **auth/**
          - **__init__.py**
            - *Description: This file marks the `auth` directory as a Python package, making its modules like `jwt.py` and `security.py` importable elsewhere in the application. It may also selectively expose functions or classes from these modules for a more convenient import interface.*
          - **jwt.py**
            - *Description: This file contains the core logic for handling JSON Web Tokens (JWTs). It is responsible for creating (encoding) new tokens for authenticated users and decoding/validating incoming tokens to secure API endpoints.*
          - **security.py**
            - *Description: This file contains security-related utilities, primarily for password hashing and verification using a library like passlib or bcrypt. It also likely defines FastAPI dependencies to enforce user authentication and role-based access control (RBAC) on API endpoints.*
        - **core/**
          - **__init__.py**
            - *Description: This file marks the `core` directory as a Python package, enabling the import of its modules like `config.py`. It can also be used to expose core components, such as the application settings, for more convenient access from other parts of the `karyaksham_api`.*
          - **config.py**
            - *Description: This file centralizes the application's configuration by using a library like Pydantic to load and validate settings from environment variables. It provides a type-safe way to access critical parameters such as database connection strings, secret keys, and external service credentials.*
        - **crud/**
          - **__init__.py**
            - *Description: This file marks the `crud` directory as a Python package, enabling the modules within it to be imported elsewhere in the application. It may also be used to expose specific CRUD objects from its sibling modules (like `crud_user`, `crud_job`) for more convenient access.*
          - **base.py**
            - *Description: This file defines a generic `CRUDBase` class that provides reusable methods for common database operations (Create, Read, Update, Delete). Specific model-focused classes, like `crud_user.py` and `crud_job.py`, inherit from this base class to avoid duplicating data access logic.*
          - **crud_job.py**
            - *Description: This file contains the data access logic for the `Job` model, implementing specific Create, Read, Update, and Delete (CRUD) operations. It serves as an abstraction layer between the API endpoints and the database, handling all direct interactions with the `jobs` table.*
          - **crud_user.py**
            - *Description: This file contains the data access logic for the `User` model. It defines functions or a class with methods to perform Create, Read, Update, and Delete (CRUD) operations on user records in the database, abstracting these database interactions from the API endpoint logic.*
        - **db/**
          - **__init__.py**
            - *Description: This file marks the `db` directory as a Python package, making its contents (like models and session management) importable. It may also be used to expose key database objects, such as the SQLAlchemy `Base` model or the session creator, to the rest of the application for easier access.*
          - **migrations/**
            - **versions/**
              - *Description: This directory holds the individual migration scripts generated by Alembic. Each Python file within represents a specific, version-controlled change to the database schema, such as creating a table or adding a column, and contains the logic to apply or revert that change.*
            - **env.py**
              - *Description: This is the Alembic configuration script that defines how database migrations are run. It provides Alembic with the necessary context, such as the database connection URL and the target SQLAlchemy model metadata, to generate and apply schema changes.*
            - **script.py.mako**
              - *Description: This is a Mako template file used by the Alembic database migration tool. It serves as the blueprint for generating new Python migration scripts, defining their basic structure, imports, and the required `upgrade()` and `downgrade()` functions.*
          - **models/**
            - **__init__.py**
              - *Description: This file marks the `models` directory as a Python package and is used to import all SQLAlchemy models (e.g., `User`, `Job`) from their respective files. This consolidation provides a single, convenient namespace for the rest of the application and for tools like Alembic to discover all defined models for generating database migrations.*
            - **job.py**
              - *Description: This file defines the SQLAlchemy ORM model for a `Job`, mapping the `jobs` database table to a Python class. It specifies the table's columns, such as `id`, `status`, `owner_id`, and any relationships to other models like `User`.*
            - **user.py**
              - *Description: This file defines the `User` SQLAlchemy model, which maps to the `users` table in the database. It specifies the table's schema, including columns like `id`, `email`, `hashed_password`, and any relationships to other database models.*
          - **session.py**
            - *Description: This file configures and provides access to the database. It is responsible for creating the SQLAlchemy database engine and the `SessionLocal` class used to manage database sessions for API requests.*
        - **integrations/**
          - **__init__.py**
            - *Description: This file marks the `integrations` directory as a Python package, allowing other parts of the application to import the modules within it that manage connections to external services like object storage and Redis.*
          - **object_storage.py**
            - *Description: This Python file defines a client or wrapper for interacting with an external object storage service like AWS S3, Google Cloud Storage, or MinIO. It abstracts the logic for uploading, downloading, and generating pre-signed URLs, providing a unified interface for the rest of the application to manage files.*
          - **redis_client.py**
            - *Description: This Python file defines a reusable client or connection manager for interacting with a Redis server. It centralizes connection logic, likely creating a configured Redis client instance that can be used throughout the application for tasks like caching, session storage, or as a message broker for Celery.*
        - **schemas/**
          - **__init__.py**
            - *Description: This `__init__.py` file marks the `schemas` directory as a Python package. This allows other parts of the application to import the Pydantic data schemas (defined in `job.py`, `user.py`, etc.) that are used for API request/response validation and data serialization.*
          - **job.py**
            - *Description: This file contains Pydantic models that define the data structure and validation rules for API requests and responses related to processing jobs, such as `JobCreate` for input and `Job` for output.*
          - **token.py**
            - *Description: This file defines the Pydantic schemas for JWT authentication tokens. It specifies the data structure for the token response sent to a client upon successful login (e.g., `access_token`, `token_type`) and for the data payload encoded within the token itself.*
          - **user.py**
            - *Description: This file defines the Pydantic schemas for the "User" entity. These schemas are used for data validation, serialization, and defining the API contract for user-related operations, such as creating, updating, and retrieving user information.*
        - **static/**
          - **favicon.ico**
            - *Description: This file, `favicon.ico`, is the standard icon for the web application, displayed in browser tabs and bookmarks. Located in the `static` directory, it is served directly by the FastAPI backend to provide a visual identity, particularly for the auto-generated API documentation pages.*
        - **utils/**
          - **__init__.py**
            - *Description: This file marks the `utils` directory as a Python package, allowing its contained modules (like `helpers.py`) to be imported elsewhere. It may also expose key utility functions to a simpler namespace for convenient access across the application.*
          - **helpers.py**
            - *Description: This file contains miscellaneous, general-purpose utility functions that support various parts of the `karyaksham_api` application. It acts as a collection of reusable code snippets that don't fit into more specific modules like `crud` or `auth`.*
        - **main.py**
          - *Description: This file serves as the main entry point for the FastAPI web application. It is responsible for creating the core FastAPI app instance, including the API routers from the `api` module, and configuring application-level settings and middleware.*
      - **karyaksham_workers/**
        - **__init__.py**
          - *Description: This `__init__.py` file marks the `karyaksham_workers` directory as a Python package, allowing its modules, such as the Celery app and tasks, to be imported by other parts of the application. It can be empty or used for package-level initialization.*
        - **celery_app.py**
          - *Description: This file initializes and configures the main Celery application instance. It is responsible for setting the message broker, result backend, and discovering task modules for the background workers.*
        - **tasks/**
          - **__init__.py**
            - *Description: This file marks the `tasks` directory as a Python package, making its modules (like `processing.py`) importable. It can also be used to selectively expose task functions from different modules to create a unified API for the `tasks` package.*
          - **processing.py**
            - *Description: This file defines the Celery background tasks responsible for executing the core data processing logic. It acts as the Python bridge that invokes the high-performance functions from the `rust_engine` to perform computations asynchronously, keeping the API responsive.*
  - **docs/**
    - **C4/**
      - **level-1-context.puml**
        - *Description: This PlantUML file (`.puml`) defines the C4 Level 1 System Context diagram for the project. It provides the highest-level architectural view, illustrating how the Pravaah system interacts with its users and any external systems.*
      - **level-2-container.puml**
        - *Description: This PlantUML file defines the C4 Level 2 (Container) diagram for the Pravaah system. It illustrates the high-level technical building blocks (e.g., API, frontend, database, worker processes) and their interactions, providing a technical overview of the system's architecture.*
    - **adrs/**
      - **001-hybrid-monolith-with-ffi.md**
        - *Description: This Architecture Decision Record (ADR) documents the foundational choice to build the system as a hybrid monolith. It justifies the decision to integrate a high-performance Rust component with the main Python backend via a Foreign Function Interface (FFI) for computationally intensive tasks.*
    - **api.md**
      - *Description: This Markdown file provides essential documentation for developers on how to use the project's backend API. It details authentication procedures, endpoint specifications, request/response formats, and usage examples to guide client-side integration.*
    - **setup.md**
      - *Description: This Markdown file (`setup.md`) serves as a developer's guide for setting up the project on a local machine. It contains step-by-step instructions on prerequisites, dependency installation, environment configuration, and commands to run the application for development and testing.*
  - **frontend/**
    - **public/**
      - **index.html**
        - *Description: This `index.html` file is the main HTML entry point for the production build of the frontend Single-Page Application (SPA). It provides the basic page structure and contains the root DOM element where the JavaScript framework (e.g., React) mounts the entire user interface.*
    - **src/**
      - **App.tsx**
        - *Description: `App.tsx` is the root component of the React single-page application. It orchestrates the overall application layout, sets up client-side routing to different pages, and often wraps the application with global providers for state, themes, or data fetching.*
      - **assets/**
        - *Description: This folder stores static assets for the frontend application, such as images, icons, fonts, and global stylesheets. These assets are typically imported directly into components or CSS files and are processed and optimized by the build tool (e.g., Vite, Webpack).*
      - **components/**
        - *Description: This directory contains reusable, self-contained UI components (e.g., buttons, input fields, modals, layout elements) for the React frontend. These components are the fundamental building blocks that are assembled within the `pages` directory to construct the application's user interface.*
      - **hooks/**
        - *Description: This folder contains custom React hooks, which are reusable functions for encapsulating stateful logic and side effects. These hooks allow sharing functionality like data fetching, form state management, or authentication status across different components in the React application.*
      - **pages/**
        - *Description: This directory contains top-level React components, where each file corresponds to a specific "page" or route in the single-page application (e.g., `HomePage.tsx`, `LoginPage.tsx`). These components orchestrate the page layout and assemble smaller, reusable UI elements from the `components/` directory.*
      - **services/**
        - **apiClient.ts**
          - *Description: This TypeScript file provides a centralized, typed client for making HTTP requests to the backend API. It encapsulates common logic like setting the base URL, attaching authentication tokens to headers, and handling API errors, offering a reusable service for data fetching across the frontend application.*
      - **main.tsx**
        - *Description: Based on its name and location, `frontend/src/main.tsx` is the primary entry point for the React front-end application. It is responsible for bootstrapping the application by rendering the root component (likely `App.tsx`) into the DOM of the main `index.html` file.*
    - **.eslintrc.cjs**
      - *Description: This is the ESLint configuration file for the frontend project, written in CommonJS format (`.cjs`). It defines the static code analysis rules to enforce code quality and a consistent style across the React/TypeScript codebase.*
    - **index.html**
      - *Description: This file is the development entry point for the frontend single-page application (SPA). It provides the basic HTML shell, including the root DOM element (e.g., `<div id="root">`) where the JavaScript application is mounted, and a script tag that loads the main application logic (e.g., `src/main.tsx`).*
    - **package.json**
      - *Description: This JSON file is the manifest for the frontend application, defining its dependencies (e.g., React, Vite) and providing runnable npm scripts for tasks like development, building, and linting. It is the central configuration file for managing the JavaScript/TypeScript project.*
    - **tsconfig.json**
      - *Description: This file is the TypeScript configuration for the frontend project. It defines the rules and compiler options for how TypeScript (`.ts`, `.tsx`) files are transpiled into JavaScript, including settings for target version, module system, and JSX handling.*
  - **infrastructure/**
    - **Dockerfile**
      - *Description: This `Dockerfile` contains the instructions to build the application's container images for both the FastAPI web server and the Celery workers. It likely uses a multi-stage build process to compile the Rust engine, install Python dependencies, and create optimized, production-ready images.*
    - **.dockerignore**
      - *Description: This file specifies which files and directories to exclude from the Docker build context. It prevents unnecessary or sensitive files, such as `.git`, local environment files, and test suites, from being included in the final image, resulting in smaller, more secure images and faster builds.*
    - **docker-compose.yml**
      - *Description: This file defines and configures the project's multi-container services for local development using Docker Compose. It orchestrates the backend API, workers, database, and message broker, enabling developers to easily spin up the entire application stack with a single command.*
    - **kubernetes/**
      - **base/**
        - **configmap.yaml**
          - *Description: This file defines a Kubernetes `ConfigMap` to store non-secret configuration data, such as environment variables, for the application. As a Kustomize `base` resource, it provides default settings that are shared across all deployment environments (e.g., staging, production).*
        - **deployment-api.yaml**
          - *Description: This file is a base Kubernetes `Deployment` manifest for the backend API application. It declaratively defines how the API server's container should be run, scaled, and managed within a Kubernetes cluster, serving as a common template for all deployment environments.*
        - **deployment-worker.yaml**
          - *Description: This file is a Kubernetes `Deployment` manifest that defines the desired state for the application's background worker pods. It specifies which container image to use, how many replicas to run, and other configuration needed to deploy and manage the asynchronous task processors (e.g., Celery workers) in the cluster.*
        - **kustomization.yaml**
          - *Description: This is the main Kustomize configuration file for the `base` layer of the application's Kubernetes setup. It declares the common resource files (like `deployment-api.yaml` and `service.yaml`) that are shared across all environments, acting as a foundation for environment-specific overlays.*
        - **service.yaml**
          - *Description: This Kubernetes manifest defines a `Service` resource, which creates a stable network endpoint and internal load balancer for the application's API pods. As a base Kustomize resource, it provides the common networking configuration for all deployment environments.*
      - **overlays/**
        - **production/**
          - **kustomization.yaml**
            - *Description: This is a Kustomize configuration file that defines the specific settings for the **production** environment. It customizes the common Kubernetes resources found in the `base` directory by applying production-only patches, such as scaling adjustments or different image tags, to generate the final deployment manifests.*
          - **scaling-patch.yaml**
            - *Description: This is a Kustomize patch file that defines the scaling configuration specifically for the production environment. It likely contains a `HorizontalPodAutoscaler` (HPA) or sets higher replica counts for the API and worker deployments, overriding the base configurations to handle production-level traffic.*
        - **staging/**
          - **kustomization.yaml**
            - *Description: This Kustomize file defines the Kubernetes configuration for the `staging` environment. It references the common resources in the `base` directory and applies staging-specific patches, such as modifying replica counts or environment variables, to create the final deployment manifests.*
          - **replica-count-patch.yaml**
            - *Description: This Kustomize patch file specifies the number of pod replicas for one or more deployments specifically within the staging environment. It overlays and modifies the base Kubernetes configuration, allowing staging to run with a different number of instances than production or development.*
    - **scripts/**
      - **entrypoint.sh**
        - *Description: This shell script serves as the primary entry point for the project's Docker containers. Its role is to perform initial setup tasks at container startup, such as running database migrations, before launching the main application process (e.g., the API server or a background worker).*
      - **run_migrations.sh**
        - *Description: This shell script executes the database migration commands, likely using Alembic, which is present in the project. It is designed to be run during the application's deployment or startup sequence to ensure the database schema is up-to-date before the API server becomes operational.*
  - **rust_engine/**
    - **Cargo.toml**
      - *Description: This is the manifest file for the `rust_engine` crate, powered by Rust's build tool, Cargo. It defines project metadata, lists external library dependencies, and specifies build profiles and compilation settings needed to create a library that can be called from Python.*
    - **src/**
      - **core/**
        - **mod.rs**
          - *Description: This file is the Rust module declaration for the `core` directory. It defines the `core` module's contents by declaring its sub-modules (like `data_processor` and `file_handler`) and controls their visibility to the rest of the `rust_engine` crate.*
        - **data_processor.rs**
          - *Description: This Rust file contains the core, high-performance algorithms for processing the input data. It is the computational heart of the `rust_engine`, responsible for executing the main business logic and transformations after data has been loaded.*
        - **file_handler.rs**
          - *Description: This Rust module handles file I/O operations for the core processing engine. It is likely responsible for efficiently reading data, possibly by streaming from an object storage service, and making it available to other parts of the engine like the `data_processor`.*
      - **utils/**
        - **mod.rs**
          - *Description: This file, `mod.rs`, is the Rust module declaration for the `utils` directory. It defines the `utils` module and makes its submodules, like `error.rs`, accessible to the rest of the `rust_engine` crate.*
        - **error.rs**
          - *Description: This file defines custom error types for the `rust_engine` crate. It centralizes error handling by creating a unified `Error` type that can represent various failure conditions from different parts of the engine, such as I/O or data processing.*
      - **lib.rs**
        - *Description: This file is the root of the `rust_engine` library crate. It uses the PyO3 framework to define the Foreign Function Interface (FFI), exposing the high-performance Rust functions to the Python backend so they can be called directly.*
  - **tests/**
    - **__init__.py**
      - *Description: This file marks the `tests` directory as a Python package, which is essential for test discovery tools like `pytest` to find and execute tests located in its subdirectories. It is often empty, but can be used for package-level test initializations.*
    - **e2e/**
      - **specs/**
        - **job_submission.spec.ts**
          - *Description: This TypeScript file contains end-to-end (E2E) tests that simulate a user's entire workflow for submitting a new job through the application's user interface. It uses a testing framework like Playwright to automate browser actions and verify that the entire system, from frontend to backend, functions correctly for this critical feature.*
      - **playwright.config.ts**
        - *Description: This is the main configuration file for the Playwright end-to-end testing framework. It defines how E2E tests are run, including settings for target browsers (e.g., Chrome, Firefox), the base URL for the application under test, test timeouts, and reporter options.*
    - **python/**
      - **__init__.py**
        - *Description: This file, `__init__.py`, marks the `tests/python` directory as a Python package. Its presence is crucial for test runners like `pytest` to discover and correctly import test modules, fixtures, and helpers from this directory and its subdirectories.*
      - **conftest.py**
        - *Description: This is a special `pytest` configuration file that defines shared test fixtures, hooks, and helper functions. Its contents, such as a test database connection or an API client instance, are automatically available to all Python unit and integration tests.*
      - **integration/**
        - **__init__.py**
          - *Description: This file marks the `integration` directory as a Python package, enabling the test runner (like `pytest`) to discover and import the integration test modules contained within it. It is typically empty and serves only to make the directory importable.*
        - **test_api_endpoints.py**
          - *Description: This Python file contains integration tests for the backend's FastAPI application. It uses a test client to send HTTP requests to the API endpoints, verifying that routes, request handling, database interactions, and authentication logic all work together correctly.*
        - **test_worker_integration.py**
          - *Description: This file contains integration tests for the asynchronous background worker system. It verifies the complete end-to-end flow of a processing job, from a task being enqueued in Celery to its successful execution by a worker and the validation of its results.*
      - **unit/**
        - **__init__.py**
          - *Description: This file marks the `tests/python/unit` directory as a Python package. This allows the test runner (like pytest) to discover and correctly import the unit test modules (e.g., `test_auth.py`, `test_crud_operations.py`) located within this directory.*
        - **test_auth.py**
          - *Description: This file contains unit tests for the project's Python authentication and security helper functions. It is responsible for verifying the correctness of isolated logic such as password hashing/verification and JSON Web Token (JWT) creation/decoding, without requiring a live database or network services.*
        - **test_crud_operations.py**
          - *Description: This file contains unit tests for the data access layer (the CRUD modules). It verifies that functions for creating, reading, updating, and deleting database records behave correctly in isolation, typically by mocking the database connection.*
    - **rust/**
      - **bridge_test.py**
        - *Description: This Python test file validates the Foreign Function Interface (FFI) bridge between the Python application and the `rust_engine`. It calls the Rust functions exposed via PyO3 to ensure they are integrated correctly and that data is marshaled properly across the language boundary.*
